<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>Hace ya un tiempo desde que programé la aplicación<a href="..\Aharphat-Android" target="_blank">CharpHat</a>, que es una aplicación que permite tomar una foto de cualquier cosa y ponerle un birrete de C# en ella. La aplicación no era perfecta, pero me ayudó a practicar el uso de los <em>custom page renderers</em>.</p>
<p>Ahora, decidí retomar el proyecto, pero en esta ocasión con la meta de aislar el código necesario para crear la interfaz y funconalidad de la cámara, de tal modo que cualquiera que quisiera implementar una cámara en su aplicación lo pudiera reutilizar en sus proyectos. Asegúrate de <strong><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage" target="_blank">descargar el código fuente</a></strong> para este post.</p>
<h2 id="abstracciones-de-forms">Abstracciones de Forms</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/CameraPage.cs" target="_blank">Aquí está el código fuente para esta sección.</a></small></p>
<p>Comencemos creando la página de Forms que nos servirá como medio de interacción con el código de clada plataforma:</p>
<pre><code class="language-csharp">public class CameraPage : ContentPage
{
    public delegate void PhotoResultEventHandler(PhotoResultEventArgs result);
    public event PhotoResultEventHandler OnPhotoResult;
</code></pre>
<p>Nada fuera de lo normal, crea una clase que derive de <code>ContentPage</code>. Añadí un <em>event handler</em> ya que que queremos obtener la foto tomada por el usuario. Ahora, agreguémos algunos métodos para llamar cada vez que el usuario realice una acción en la página (en este caso, el usuario podrá tomar una foto o cancelar la acción):</p>
<pre><code class="language-csharp">public void SetPhotoResult(byte[] image, int width = -1, int height = -1)
{
    OnPhotoResult?.Invoke(new PhotoResultEventArgs(image, width, height));
}

public void Cancel()
{
    OnPhotoResult?.Invoke(new PhotoResultEventArgs());
} 
</code></pre>
<p>Como referencia, mira las propiedades dentro de la clase <code>PhotoResultEventArgs</code>:</p>
<pre><code class="language-csharp">public bool Success { get; private set; }
public int Width { get; private set; }
public int Height { get; private set; }
public byte[] Image { get; private set; }
</code></pre>
<p>Ahora es momento de seguir al código específico de cada plataforma.</p>
<h2 id="in-xamarin.ios">In Xamarin.iOS</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/iOS/CameraPageRenderer.cs" target="_blank">Aquí está el código fuente para esta sección.</a></small></p>
<p>Para ser sincero, la implementación en iOS es la más sencilla por mucho. Comenzamos por crear una clase que derive de <code>PageRenderer</code> y le añadimos el atributo <code>ExportRenderer</code>:</p>
<pre><code class="language-csharp">[assembly: ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]
namespace FullCameraPage.iOS
{
	public class CameraPageRenderer : PageRenderer
</code></pre>
<p>Ahora, y esto es muy importante, tienes que sobreescribir el método <code>ViewDidLoad</code> dado que es llamado tan pronto nuestra página es cargada por el sistema operativo. Para organizar un poco mejor el código, partamos el código en varios métodos:</p>
<pre><code class="language-csharp">public override async void ViewDidLoad()
{
    base.ViewDidLoad();
    SetupUserInterface();
    SetupEventHandlers();
    AuthorizeCameraUse();
    SetupLiveCameraStream();
}
</code></pre>
<h3 id="setupuserinterface">SetupUserInterface</h3>
<p>Tal y como el nombre lo dice, aquí es donde tenemos que construir la interfaz. Como podrás haber adivinado, todo se hace con código, pero no te preocupes, es muy sencillo en tanto tu interfaz no sea muy complicada, pero puedes hacer lo que tu quieras aquí.</p>
<p>Para este ejemplo la interfaz consistrá de un par de botones y una superficie donde la vista en vivo de la cámara se mostrará, así que declara las siguientes campos a nivel de clase:</p>
<pre><code class="language-csharp">VectorButton takePhotoButton;
VectorButton cancelPhotoButton;
UIView liveCameraStream;
</code></pre>
<p>Ahora para poner los controles en su lugar necesitas pensar como si estuvieras trabajando con un <em>relative layout</em>, lo que significa que hay que poner la posición del control en la pantalla. Por ejemplo, observa cómo se ubica la vista de la cámara:</p>
<pre><code class="language-csharp">private void SetupUserInterface()
{
    // Code ommited ...
    liveCameraStream = new UIView()
    {
        Frame = new CGRect(0f, 0f, View.Bounds.Width, View.Bounds.Height)
    };
    // Code ommited ...
    View.Add(liveCameraStream);
    // Code ommited ...
}
</code></pre>
<h3 id="setupeventhandlers">SetupEventHandlers</h3>
<p>Ahora que ya hemos terminado la interfaz, podemos <em>conectar</em> los manejadores de eventos a cada control, por suerte en nuestro ejemplo únicamente tenemos dos botones en la pantalla: para tomar fotos y para cancelar la captura.</p>
<pre><code class="language-csharp">cancelPhotoButton.TouchUpInside += (s, e) =&gt;
{
    (Element as CameraPage).Cancel();
};

takePhotoButton.TouchUpInside += async (s, e) =&gt;
{
    var data = await CapturePhoto();
    UIImage imageInfo = new UIImage(data);

    (Element as CameraPage).SetPhotoResult(data.ToArray(),
                                           (int)imageInfo.Size.Width,
                                           (int)imageInfo.Size.Height);
};
</code></pre>
<p>La propiedad <code>Element</code> contiene una referencia a la página asociada con el <em>renderer</em> y es nuestro medio de interacción con el proyecto de Forms. Si te preguntas sobre el método <code>CapturePhoto</code>, lo veremos más adelante.</p>
<h2 id="authorizecamerause">AuthorizeCameraUse</h2>
<p>Ahora es momento de solicitar permiso al usuario para usar su cámara.</p>
<pre><code class="language-csharp">var authorizationStatus = AVCaptureDevice.GetAuthorizationStatus(AVMediaType.Video);
if (authorizationStatus != AVAuthorizationStatus.Authorized)
{
    await AVCaptureDevice.RequestAccessForMediaTypeAsync(AVMediaType.Video);
}
</code></pre>
<p>Pero antes de ejecutar el código anterior tienes que agregar la entrada <code>Privacy - Camera Usage Description</code> al archivo Info.plist en tu proyecto.</p>
<h3 id="setuplivecamerastream">SetupLiveCameraStream</h3>
<p>Ahora la parte &quot;complicada&quot;.</p>
<p>Comienza delcarando a nivel de clase una <code>AVCaptureSession</code>, <code>AVCaptureDeviceInput</code> y <code>AVCaptureStillImageOutput</code>,  ya que estos nos ayudaran a acceder a la cámara, mostrarla en vivo, y capturar la imagen.</p>
<p>Entonces dentro de <code>SetupLiveCameraStream</code>, inicializa una sesión de captura, crea una capa de previsualización del mismo tamaño que nuestra <code>liveCameraStream</code>, y añádela como una subcapa de esta:</p>
<pre><code class="language-csharp">    captureSession = new AVCaptureSession();
    var videoPreviewLayer = new AVCaptureVideoPreviewLayer(captureSession)
    {
        Frame = liveCameraStream.Bounds
    };
    liveCameraStream.Layer.AddSublayer(videoPreviewLayer);
</code></pre>
<p>Después, &quot;crea&quot; un dispositivo de captura (que puedes configurar de acuerdo a tus necesidades). Y entonces de éste dispositivo crea una entrada para la sesión de captura:</p>
<pre><code class="language-csharp">    var captureDevice = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
    ConfigureCameraForDevice(captureDevice);
    captureDeviceInput = AVCaptureDeviceInput.FromDevice(captureDevice);
</code></pre>
<p>Ya tenemos una entrada (la cámara del dispositivo), ahora necesitamos una salida, que será una fotografía en formato jpeg:</p>
<pre><code class="language-csharp">    var dictionary = new NSMutableDictionary();
    dictionary[AVVideo.CodecKey] = new NSNumber((int)AVVideoCodec.JPEG);
    stillImageOutput = new AVCaptureStillImageOutput()
    {
        OutputSettings = new NSDictionary()
    };
</code></pre>
<p>Terminamos estableciendo la entrada y salida de la sesión de captura y la iniciamos:</p>
<pre><code class="language-csharp">    captureSession.AddOutput(stillImageOutput);
    captureSession.AddInput(captureDeviceInput);
    captureSession.StartRunning();
</code></pre>
<h3 id="capturephoto">CapturePhoto</h3>
<p>Finalmente la cereza del pastel. El código para capturar la foto. En sí, el código es bastante simple: Toma la salida y obten una imagen fija de ella, ya que nosotros solo necesitamos los bytes (<code>NSData</code>) que contenga la foto tomada:</p>
<pre><code class="language-csharp">public async Task&lt;NSData&gt; CapturePhoto()
{
    var videoConnection = stillImageOutput.ConnectionFromMediaType(AVMediaType.Video);
    var sampleBuffer = await stillImageOutput.CaptureStillImageTaskAsync(videoConnection);
    var jpegImageAsNsData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer);
    return jpegImageAsNsData;
}
</code></pre>
<h2 id="in-xamarin.android">In Xamarin.Android</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/Droid/CameraPageRenderer.cs" target="_blank">Aquí está el código fuente para esta sección.</a></small></p>
<p>Esta implementación no es tan limpia como en iOS. Principalmente porque Android hace más énfasis en el uso de <em>listeners</em> que en manejadores de evento. Como sea, ese no es un problema para nosotros.</p>
<p>Como en iOS, comienza creando una clase que derive de <code>PageRenderer</code> y también haz que implmente la interfaz <code>TextureView.ISurfaceTextureListener</code>. No olvides el atributo <code>ExportRenderer</code>:</p>
<pre><code class="language-csharp">[assembly: Xamarin.Forms.ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]
namespace FullCameraPage.Droid
{
    public class CameraPageRenderer : PageRenderer, TextureView.ISurfaceTextureListener
</code></pre>
<p>Después, sobreescribe el método <code>OnElementChanged</code> (si ya has trabajado con <em>custom renderers</em> antes, este método te puede parecer familiar), ya que este será llamado cada vez que una <code>CameraPage</code> es mostrada en la pantalla:</p>
<pre><code class="language-csharp">protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
{
    base.OnElementChanged(e);
    SetupUserInterface();
    SetupEventHandlers();
</code></pre>
<h3 id="setupuserinterface-1">SetupUserInterface</h3>
<p>En este método se debe crear la interfaz de la cámara, puedes hacerlo mediante un archivo <em>axml</em> e &quot;inflarlo&quot; con los mecanismos de Android... o, como en este ejemplo, crearlo en código.</p>
<p>Para este ejemplo vamos a necesitar un <code>RelativeLayout</code> como contenedor, un <code>TextureView</code> para mostrar la cámara y un botón para tomar la foto. Declara todo a nivel de clase:</p>
<pre><code class="language-csharp">RelativeLayout mainLayout;
TextureView liveView;
PaintCodeButton capturePhotoButton;
</code></pre>
<p>Solamente falta instanciarlos y añadirlos a la pantalla, por ejemplo, observa cómo se crea el contenedor y se le añada el control <code>TextureView</code>:</p>
<pre><code class="language-csharp">void SetupUserInterface()
{
    mainLayout = new RelativeLayout(Context);
    RelativeLayout.LayoutParams mainLayoutParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MatchParent,
        RelativeLayout.LayoutParams.MatchParent);
    mainLayout.LayoutParameters = mainLayoutParams;

    liveView = new TextureView(Context);
    RelativeLayout.LayoutParams liveViewParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MatchParent, 
        RelativeLayout.LayoutParams.MatchParent);
    liveView.LayoutParameters = liveViewParams;
    mainLayout.AddView(liveView);
    
    // Code ommited...

    AddView(mainLayout);
}
</code></pre>
<p>Antes de continuar hay otro método que debemos sobreescribir para darle al contenedor su tamaño (y también lo podemos usar para acomodar la interfaz correctamente):</p>
<pre><code class="language-csharp">protected override void OnLayout(bool changed, int l, int t, int r, int b)
{
    base.OnLayout(changed, l, t, r, b);
    if (!changed)
        return;
    var msw = MeasureSpec.MakeMeasureSpec(r - l, MeasureSpecMode.Exactly);
    var msh = MeasureSpec.MakeMeasureSpec(b - t, MeasureSpecMode.Exactly);
    mainLayout.Measure(msw, msh);
    mainLayout.Layout(0, 0, r - l, b - t);

    capturePhotoButton.SetX( mainLayout.Width / 2 - 60);
    capturePhotoButton.SetY(mainLayout.Height - 200);
}
</code></pre>
<h3 id="setupeventhandlers-1">SetupEventHandlers</h3>
<p>Como dije antes, Android depende mucho de <em>event listeners</em> en lugar de  <em>event handlers</em>, así que este método es muy sencillo. Necesitamos colocar un manejador de evento al botón que tomará la foto, asi como asignar un escuchador que estará atento al estado del control  <code>SurfaceTexture</code> (¿Recuerdas que nuestro <em>renderer</em> implementa una interfaz?):</p>
<pre><code class="language-csharp">capturePhotoButton.Click += async (sender, e) =&gt;
{
    var bytes = await TakePhoto();
    (Element as CameraPage).SetPhotoResult(bytes, liveView.Bitmap.Width, liveView.Bitmap.Height);
};
liveView.SurfaceTextureListener = this;
</code></pre>
<p>Ah, y otra cosa, vamos a sobreescribir el comportamiento del botón &quot;Atrás&quot; para que funcione para cancelar la fotografía:</p>
<pre><code class="language-csharp">public override bool OnKeyDown(Keycode keyCode, KeyEvent e)
{
    if (keyCode == Keycode.Back)
    {
        (Element as CameraPage).Cancel();
        return false;
    }
    return base.OnKeyDown(keyCode, e);
}
</code></pre>
<h3 id="textureview.isurfacetexturelistener-implementation">TextureView.ISurfaceTextureListener implementation</h3>
<p>Ahora toca implementar el núcleo de la página. Comienza por escribir el código para el método <code>OnSurfaceTextureAvailable</code> en donde vamos a preparar la salida de la cámara... pero primero necesitamos una cámara, ¿cierto?<br />
A nivel de clase declara una <code>Camera</code>:</p>
<pre><code class="language-csharp">Android.Hardware.Camera camera;
</code></pre>
<p>Dentro del método abre la cámara (por default tomará la cámara trasera del dispositivo) y obtén sus parámetros. Los necesitamos para elegir el tamaño de previsualización correcto porque queremos que se vea bien en nuestra app:</p>
<pre><code class="language-csharp">camera = Android.Hardware.Camera.Open();
var parameters = camera.GetParameters();
</code></pre>
<p>Una vez que tenemos los parámetros a mano, podemos obtener los <code>PreviewSizes</code> y de ellos elegir el que mejor se ajusta a nuestras necesidades. En este caso estoy usando una simple <a href="#">expresión linq</a> para obtener el mejor tamaño de acuerdo a la relación de aspecto:</p>
<pre><code class="language-csharp">var aspect = ((decimal)height) / ((decimal)width);

var previewSize = parameters.SupportedPreviewSizes
                            .OrderBy(s =&gt; Math.Abs(s.Width / (decimal)s.Height - aspect))
                            .First();

parameters.SetPreviewSize(previewSize.Width, previewSize.Height);
camera.SetParameters(parameters);
</code></pre>
<p>Termina estableciendo el valor de <code>surface</code> como la textura de previsualización, una vez hecho esto, lo único que queda por hacer es iniciar la cámara:</p>
<pre><code class="language-csharp">camera.SetPreviewTexture(surface);
StartCamera();
</code></pre>
<p>Hay otro método en el que debemos escribir código, este es <code>OnSurfaceTextureDestroyed</code> en donde debemos detener el uso de la cámara, así que únicamente escribe el código siguiente en él:</p>
<pre><code class="language-csharp">StopCamera();
return true;
</code></pre>
<h3 id="startcamera-and-stopcamera">StartCamera and StopCamera</h3>
<p>Este par de métodos son bastante simples también, para <code>StartCamera</code> únicamente tenemos que rotar la previsualización para hacer que se vea correctamente en la pantalla (en este caso está establecido para que se vea verticalmente), y terminamos iniciando la cámara:</p>
<pre><code class="language-csharp">camera.SetDisplayOrientation(90);
camera.StartPreview();
</code></pre>
<p>El métodod <code>StopCamera</code> detiene la previsualización y libera la cámara para que otras aplicaciones puedan acceder a ella:</p>
<pre><code class="language-csharp">camera.StopPreview();
camera.Release();
</code></pre>
<h3 id="takephoto">TakePhoto</h3>
<p>Para tomar una foto, lo que hay que hacer es obtener una imagen fija de lo que se muestra en el video en vivo dentro de la <code>TextureView</code>, aquí está el código para hacerlo y regresar los bytes correspondientes:</p>
<pre><code class="language-csharp">camera.StopPreview();
var ratio = ((decimal)Height) / Width;
var image = Bitmap.CreateBitmap(liveView.Bitmap, 0, 0, liveView.Bitmap.Width, (int)(liveView.Bitmap.Width * ratio));
byte[] imageBytes = null;
using (var imageStream = new System.IO.MemoryStream())
{
    await image.CompressAsync(Bitmap.CompressFormat.Jpeg, 50, imageStream);
    image.Recycle();
    imageBytes = imageStream.ToArray();
}
camera.StartPreview();
return imageBytes;
</code></pre>
<p>Y así es como después de tanto código podemos hacer uso de la cámara. Sigue leyendo para encontrar un ejemplo de uso:</p>
<h2 id="usage-in-forms">Usage in Forms</h2>
<pre><code class="language-csharp">var cameraPage = new CameraPage();
cameraPage.OnPhotoResult += CameraPage_OnPhotoResult;
Navigation.PushModalAsync(cameraPage);  
// ...
async void CameraPage_OnPhotoResult(Pages.PhotoResultEventArgs result)
{
    await Navigation.PopModalAsync();
    if (!result.Success)
        return;
    Image.Source = ImageSource.FromStream(() =&gt; new MemoryStream(result.Image));
</code></pre>
<p>Si <strong><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage" target="_blank">descargas el código fuente</a></strong> y lo ejecutas, verás algo como esto:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/DgFEK9tPKs0" frameborder="0" allowfullscreen></iframe>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>El código para este post está basado completamente en el código de la <a href="..\Aharphat-Android" target="_blank">CharpHat app</a>,  que a su vez está basado en el código de la app <a href="https://blog.xamarin.com/build-your-own-snapchat-clone-with-xamarin-forms-and-azure/" target="_blank">Moments</a> de <a href="https://github.com/pierceboggan" target="_blank">Pierce Boggan</a>.</p>


            </div>
          </div>
        
</body>
</html>
