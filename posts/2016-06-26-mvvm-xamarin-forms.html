<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!‚Äì‚Äì Made with Lockdown: https://github.com/fferegrino/lockdown ‚Äì‚Äì>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<h1 id="mvvmdex">Mvvmdex</h1>
<p>Soy un gran fan√°tico de Pok√©mon y es por eso que para este post haremos una aplicaci√≥n que se encargar√° de buscar pok√©mons en la Pok√©API usando la <a href="#">Jirapi</a> y mostrar los datos encontrados en la pantalla. En esta aplicaci√≥n se implementa el patr√≥n MVVM para la separaci√≥n de responsabilidades.</p>
<img src="http://i.giphy.com/Mo4P4sEJNUKeQ.gif" />
<h2 id="introduccion">Introducci√≥n</h2>
<p>Dentro de este post voy a asumir que ya tienes un entendimiento b√°sico de c√≥mo es que funciona Xamarin, Xamarin.Forms y la teor√≠a de MVVM, si no, te invito a que consultes mi post sobre <a href="../../tv/xamarin/">qu√© es Xamarin</a>, el <a href="../../tv/xamarin-forms/">video sobre Xamarin.Forms</a>, y el <a href="../../tv/mvvm">video sobre MVVM</a>.</p>
<h2 id="estructura">Estructura</h2>
<p>Como ya sabr√°s, el <a href="organizacion-codigo-visual-studio">c√≥digo en Visual Studio</a> se organiza en proyectos, y esta es la organizaci√≥n de los proyectos para esta peque√±a app:</p>
<p>&lt;img src=&quot;/images/mvvm__codeorg.png&quot; title=<>Code organization</> /&gt;</p>
<p>La separaci√≥n de MVVM se puede observar en que el proyecto <code>Mvvmdex.Views</code> se relaciona con <code>Mvvmdex.ViewModels</code> y a su vez este √∫ltimo se relaciona con <code>Mvvmdex.Models</code>, <strong>nunca hay relacion directa entre las vistas y los modelos</strong>.</p>
<h2 id="modelo">Modelo</h2>
<p>Para este proyecto, el modelo est√° contenido dentro de <code>Mvvmdex.Models</code>. Como sabe, en el modelo es donde se realiza el acceso a datos y la l√≥gica de la aplicaci√≥n. En esta aplicaci√≥n, el <em>Mvvmdex</em>, √∫nicamente se consulta a la Pok√©API dentro de la clase <code>MvvmdexClient</code>. Como puedes ver, no tiene ninguna relaci√≥n con la vista:</p>
<pre><code class="language-csharp">public async Task&lt;Pokemon&gt; SearchForPokemon(string pokemonName)
{
	try
	{
		var pkmn = await _client.Get&lt;Jirapi.Resources.Pokemon&gt;(pokemonName);
		var species = await pkmn.Species.GetResource(_client);
		return new Pokemon
		{
			Id = pkmn.Id,
			Name = pkmn.Name,
			Description = species.FlavorTextEntries
				.FirstOrDefault(te =&gt; te.Language.Name == &quot;en&quot;)?
				.FlavorText.Replace(&quot;\n&quot;,&quot;&quot;),
			Shape = species.Shape.Name
		};
	}
	catch
	{
		return null;
	}
}
</code></pre>
<h2 id="viewmodels">ViewModels</h2>
<p>Para este proyecto, el modelo est√° contenido dentro de <code>Mvvmdex.ViewModels</code>. Esta es la parte m√°s complicada, hay que recordar que este es el intermediario entre la vista y el modelo. Para esta app √∫nicamente existe un solo ViewModel, <code>PokemonSearchViewModel</code>, pero es muy com√∫n que tu tengas varios dependiendo del tama√±o y complejidad de tu aplicaci√≥n.</p>
<p>Esta secci√≥n tiene relaci√≥n directa con el Modelo, en el <em>Mvvmdex</em> se hace referencia en el cliente <code>MvvmdexClient</code>:</p>
<pre><code class="language-csharp">private MvvmdexClient _client;

public PokemonSearchViewModel()
{
	_client = new MvvmdexClient(); // &lt;- Model
}
</code></pre>
<p>El modelo puede enviar y recibir mensajes del <em>viewmodel</em> a trav√©s de m√©todos.</p>
<h3 id="inotifypropertychanged">INotifyPropertyChanged</h3>
<p>La interfaz <code>INotifyPropertyChanged</code> permitir√° a la vista ser notificada cada vez que suceda alg√∫n cambio en el <em>viewmodel</em>. La interfaz √∫nicamente expone el evento <code>PropertyChanged</code> que debemos invocar cada vez que queremos notificar a la vista alg√∫n cambio. Para hacer la tarea m√°s sencilla, se crea un m√©todo auxiliar:</p>
<pre><code class="language-csharp">public void RaiseOnPropertyChange([CallerMemberName] string propertyName = null)
{
	if (PropertyChanged != null)
	{
		PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
	}
}
</code></pre>
<p>El atributo <code>CallerMemberName</code> nos facilitar√° la tarea, ya que con √©l aseguramos que el nombre de la propiedad desde la que lo llamemos ser√° colocada ah√≠ para notificar a la vista sobre la propiedad correcta.</p>
<p>Es importante decir que existen muchos frameworks de <em>mvvm</em> que ya contienen una implementaci√≥n de esta interfaz y para nosotros bastar√≠a con derivar nuestros objetos de dicha implementaci√≥n para no tener que hacerla nosotros mismos.</p>
<h3 id="propiedades">Propiedades</h3>
<p>Con las propiedades hay una peque√±a limitante: no pueden ser propiedades auto-implementadas, ya que es necesario llamar a nuestro m√©todo auxiliar creado m√°s arriba. Mira la propiedad <code>PokemonName</code>:</p>
<pre><code class="language-csharp">private string _pokemonName;

public string PokemonName
{
	get { return _pokemonName; }
	set { _pokemonName = value; RaiseOnPropertyChange(); /* RaiseOnPropertyChange(&quot;PokemonName&quot;) */ }
}
</code></pre>
<p>Como puedes ver, cada vez que ocurre un cambio en la propiedad, se est√° notificando a qui√©n desee sobre el cambio, en nuestro caso, la vista es quien desea ser notificada. M√°s adelante, con los <em>data bindings</em>, enlazaremos las propiedades en el <em>viewmodel</em> con elementos dentro de la vista.</p>
<h3 id="commands">Commands</h3>
<p>Los <em>commands</em> es otro de los mecanismos que contempla <em>mvvm</em> para la comunicaci√≥n entre los componentes, y es a trav√©s de ellos que se trasladan algunos de los eventos generados en la vista hacia el <em>viewmodel</em>. En Xamarin.Forms un comando no es m√°s que una instancia de objeto que implementa la interfaz <code>ICommand</code>, en el caso de esta app, tenemos el comando <code>BuscaPokemonCommand</code> que lo √∫nico que hace es ejecutar una <code>Action</code> cuando se ejecuta.</p>
<pre><code class="language-csharp">public class BuscaPokemonCommand : ICommand
{
	private readonly Action _search;
	public BuscaPokemonCommand(Action search)
	{
		_search = search;
	}

	public bool CanExecute(object parameter)
	{
		return true;
	}

	public void Execute(object parameter)
	{
			_search();
	}

	public event EventHandler CanExecuteChanged;
}
</code></pre>
<p>La interfaz ICommand contiene tres miembros:</p>
<ul>
<li><code>bool CanExecute(object parameter)</code> - con el cual podemos decidir si el comando se puede ejecutar</li>
<li><code>void Execute(object parameter)</code> - en el cual debemos efectuar la ejecuci√≥n</li>
<li><code>event EventHandler CanExecuteChanged</code> - es un evento que debe invocarse cada vez que las condiciones bajo las que se puede invocar un comando han cambiado.</li>
</ul>
<p>Es importante mencionar que al igual que con la interfaz <code>INotifyPropertyChanged</code>, ya existen varios frameworks que proveen implementaciones gen√©ricas de <code>ICommand</code> para evitarnos el tedio de escribirlos nosotros mismos.</p>
<h4 id="en-el-viewmodel">En el ViewModel</h4>
<p>Ahora, la forma en la que se usa este comando es a trav√©s de una propiedad ya que m√°s adelante ser√° enlazada con un control dentro de la vista:</p>
<pre><code class="language-csharp">private ICommand _buscaPokemonCommand;
public ICommand BuscaPokemonCommand
{
	get
	{
		if (_buscaPokemonCommand == null)
		{
			Action buscaPokemonAction = async () =&gt;
			{
			var pokemon = await _client.SearchForPokemon(SearchTerms.ToLower());

				HasCoincidence = pokemon != null;
				if (HasCoincidence)
				{
					Description = pokemon.Description;
					PokemonName = String.Format(&quot;{0:D3} {1}&quot;, pokemon.Id, pokemon.Name);
					Shape = pokemon.Shape;
				}
			};
			_buscaPokemonCommand = new BuscaPokemonCommand(buscaPokemonAction);
		}
		return _buscaPokemonCommand;
	}
}
</code></pre>
<h2 id="vista">Vista</h2>
<p>Hay que recordar que en Forms podemos crear nuestras interfaces a trav√©s de c√≥digo C# o XAML, para esta ocasi√≥n usar√© XAML para crear la pantalla.</p>
<p>La vista de la aplicaci√≥n es bastante simple, √∫nicamente consta de un cuadro de b√∫squeda (<code>SearchBar</code>), un contenedor (<code>StackLayout</code>) que contiene varias etiquetas (<code>Label</code>) para mostrar los datos de Pok√©mon en cuesti√≥n y por √∫ltimo una etiqueta para mostrar en caso de que no encontremos un pok√©mon que coincida con nuestra b√∫squeda:</p>
<pre><code class="language-xml">&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; 
		xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; 
		xmlns:converters=&quot;clr-namespace:Mvvmdex.Views.Converters&quot; 
		x:Class=&quot;Mvvmdex.Views.MvvmdexPage&quot; 
		Title=&quot;Mvvmdex&quot;&gt;
	&lt;ContentPage.Resources&gt;
		&lt;ResourceDictionary&gt;
			&lt;converters:BooleanInverterConverter x:Key=&quot;BooleanInverter&quot; /&gt;
			&lt;converters:ShapeToEmojiConverter x:Key=&quot;ShapeToEmoji&quot; /&gt;
		&lt;/ResourceDictionary&gt;
	&lt;/ContentPage.Resources&gt;
	&lt;Grid&gt;
		&lt;Grid.RowDefinitions&gt;
			&lt;RowDefinition Height=&quot;Auto&quot; /&gt;
			&lt;RowDefinition Height=&quot;*&quot; /&gt;
		&lt;/Grid.RowDefinitions&gt;
		
		&lt;SearchBar Grid.Row=&quot;0&quot; SearchCommand=&quot;{Binding BuscaPokemonCommand}&quot; 
			Text=&quot;{Binding SearchTerms}&quot; /&gt;
		
		&lt;StackLayout IsVisible=&quot;{Binding HasCoincidence}&quot; Grid.Row=&quot;1&quot; Padding=&quot;20&quot; Spacing=&quot;10&quot;&gt;
			&lt;Label Text=&quot;{Binding PokemonName}&quot; FontSize=&quot;Large&quot; /&gt;
			&lt;Label Text=&quot;{Binding Description}&quot; /&gt;
			&lt;Label Text=&quot;{Binding Shape, Converter={StaticResource ShapeToEmoji}}&quot; /&gt;
		&lt;/StackLayout&gt;
		
		&lt;Label IsVisible=&quot;{Binding HasCoincidence, Converter={StaticResource BooleanInverter}}&quot; 
			Text=&quot;üòï&quot; Grid.Row=&quot;1&quot; HorizontalTextAlignment=&quot;Center&quot; FontSize=&quot;100&quot; /&gt;
	&lt;/Grid&gt;
&lt;/ContentPage&gt;
</code></pre>
<h3 id="data-bindings">Data bindings</h3>
<p>Si ves mucho <code>Binding</code> en el c√≥digo no te preocupes, es algo muy com√∫n en <em>MVVM</em>, y es que es ah√≠ donde ocurre el enlace de la vista al <em>viewmodel</em>, una de las partes centrales del patr√≥n. Los <em>data bindings</em> se encargan de &quot;estar al tanto&quot; de los cambios que informa el <em>viewmodel</em> y reflejarlos en la pantalla cuando sucedan.</p>
<p>Por ejemplo, la etiqueta en la que se muestra el nombre y el n√∫mero del Pok√©mon:</p>
<pre><code class="language-xml">&lt;Label Text=&quot;{Binding PokemonName}&quot; FontSize=&quot;Large&quot; /&gt;
</code></pre>
<p>Mediante los <em>bindings</em> el texto del <code>Label</code> cambiar√° cada vez que la propiedad <code>PokemonName</code> lo haga.</p>
<p>Sin embargo, los bindings no son solo de una direcci√≥n (<em>viewmodel</em> ‚Üí vista), sino que tambi√©n pueden ser usados al rev√©s. Tomemos, por ejemplo el control <code>SearchBar</code>:</p>
<pre><code class="language-xml">&lt;SearchBar Grid.Row=&quot;0&quot; SearchCommand=&quot;{Binding BuscaPokemonCommand}&quot; Text=&quot;{Binding SearchTerms}&quot; /&gt;
</code></pre>
<p>Entonces cada vez que el usuario cambie el texto de la caja de b√∫squeda, la propiedad <code>SearchTerms</code> del <em>viewmodel</em> tambi√©n cambiar√°. Y no solo eso, sino que tambi√©n el control tiene enlazado el comando <code>BuscaPokemonCommand</code>, el comando se ejecutar√° cuando el usuario decida buscar Pok√©mons.</p>
<p>Como puedes ver, las tres propiedades (<code>PokemonName</code>, <code>SearchTerms y </code>SearchCommand`) existen en el <em>viewmodel</em>. En caso de que no existiera alguna, no pasar√° absolutamente nada, no habr√° errores ni excepciones, es por eso que se dice que es un poco dif√≠cil de <em>debuggear</em> estos enlaces de datos.</p>
<h3 id="converters">Converters</h3>
<p>Adem√°s de <code>Binding</code> probablemente te hayas fijado en la palabra <code>Converter</code>... as√≠ que es hora de explicar los <em>converters</em>. Estos no son m√°s que instancias de tipos que implementan la interfaz <code>IConvertValue</code> que en pocas palabras hace eso: convertir valores.</p>
<p>En el m√°s estricto de los sentidos el <em>viewmodel</em> debe ser independiente de la plataforma y exponer solamente las propiedades necesarias para que la vista opere. Pero, ¬øqu√© pasa si nosotros queremos extender un poco m√°s esa funcionalidad?</p>
<p>Por ejemplo, en la app <em>Mvvmdex</em> quisiera mostrar u ocultar un panel dependiendo de si el Pok√©mon fue encontrado o no, el <em>viewmodel</em> ofrece la propiedad booleana <code>HasConicidence</code> que podemos ligar a <code>IsVisible</code>:</p>
<pre><code class="language-xml">&lt;StackLayout IsVisible=&quot;{Binding HasCoincidence}&quot; ... /&gt;
</code></pre>
<p>Sin embargo, no podemos ligar esa propiedad directamente con otro control para que se &quot;esconda&quot; cuando haya coincidencia, es por eso que se implement√≥ la clase <code>BooleanInverterConverter</code>:</p>
<pre><code class="language-csharp">public class BooleanInverterConverter : IValueConverter
{
	public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
	{
		return !(bool)value;
	}

	public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
	{
		throw new NotImplementedException();
	}
}
</code></pre>
<p>Que como puedes ver tiene dos m√©todos, uno para convertir &quot;de ida&quot; y uno &quot;de vuelta&quot;, esta app solo hace uso del &quot;de ida&quot; y √∫nicamente niega el valor booleano que se le pase.</p>
<p>Luego entonces ya podemos usarlo en nuestra pantalla, primero declar√°ndolo dentro de los recursos de la pantalla:</p>
<pre><code class="language-xml">&lt;ContentPage.Resources&gt;
	&lt;ResourceDictionary&gt;
		&lt;converters:BooleanInverterConverter x:Key=&quot;BooleanInverter&quot; /&gt; 
</code></pre>
<p>Para luego usarlo junto con un enlace a datos en un control:</p>
<pre><code class="language-xml">&lt;Label IsVisible=&quot;{Binding HasCoincidence, Converter={StaticResource BooleanInverter}}&quot; 
	Text=&quot;üòï&quot; Grid.Row=&quot;1&quot; HorizontalTextAlignment=&quot;Center&quot; FontSize=&quot;100&quot; /&gt;
</code></pre>
<h3 id="enlace-con-el-viewmodel">Enlace con el ViewModel</h3>
<p>Para terminar todo esto, falta un paso muy importante, y es el de relacionar de alguna manera la vista con el <em>viewmodel</em>. Hay muchas maneras de hacer esto, sin embargo, una de las m√°s pr√°cticas es establecer el nuestro <em>viewmodel</em> como el <code>BindingContext</code> de la vista. Para esta app, la acci√≥n se realiza en el <em>code behind</em> de la p√°gina <code>MvvmdexPage</code>:</p>
<pre><code class="language-csharp">public partial class MvvmdexPage : ContentPage
{
	public MvvmdexPage()
	{
		BindingContext = new PokemonSearchViewModel(); // &lt;- ViewModel
		// ....
</code></pre>
<h2 id="para-cerrar">Para cerrar</h2>
<p>Existen muchas m√°s posibilidades para hacer m√°s robusta una aplicaci√≥n de Forms con <em>MVVM</em>, como el uso de la inyecci√≥n de dependencias para integrar m√°s capacidades como navegaci√≥n entre pantallas, acceso a sensores del tel√©fono y m√°s. Tambi√©n puedes integrar frameworks como <a href="http://www.mvvmlight.net/doc/" target="_blank" rel="nofollow">mvvm light</a> o <a href="https://github.com/PrismLibrary/Prism#prism" target="_blank" rel="nofollow">Prism</a> para liberarte de hacer tus propias implementaciones de <code>ICommand</code> e <code>INotifyPropertyChanged</code>.</p>
<p>Espero que este post te haya servido, recuerda que la mejor forma de aprender es experimentando, as√≠ que te invito a que <a href="https://github.com/ThatCSharpGuy/xfmvvm" target="_blank" rel="nofollow">descargues el c√≥digo de GitHub</a> y juegues un poco con √©l, si tienes dudas, puedes contactarme sin problemas.</p>


            </div>
          </div>
        
</body>
</html>
